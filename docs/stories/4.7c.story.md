# Story 4.7c: Escalation Notifications and Timing

## Status
Pending

## Story
**As a supervisor,**
**I want escalation alerts for overdue report processing,**
**so that workflow bottlenecks are identified and resolved.**

## Acceptance Criteria
1. Escalation notifications for reports pending beyond defined timeframes

## Tasks / Subtasks
- [ ] Create escalation timing configuration system (AC: 1)
  - [ ] Build EscalationConfig component for defining timeframe thresholds and escalation rules
  - [ ] Implement configurable escalation levels with increasing urgency and notification scope
  - [ ] Add business rule configuration for different report types and outlet priorities
  - [ ] Create escalation schedule management with working hours and holiday considerations
  - [ ] Integrate with authentication system for supervisor and admin configuration access
- [ ] Implement automated escalation detection system (AC: 1)
  - [ ] Build escalation monitoring service with scheduled checks for overdue reports
  - [ ] Create aging calculation logic for reports in different workflow states
  - [ ] Implement escalation trigger evaluation based on configurable timeframes and business rules
  - [ ] Add escalation event generation with proper context and priority classification
  - [ ] Create escalation prevention logic for reports with valid reasons for delays
- [ ] Build supervisor escalation notification system (AC: 1)
  - [ ] Create supervisor-specific notification targeting with role-based recipient identification
  - [ ] Implement escalation notification templates with detailed context and actionable information
  - [ ] Add escalation severity classification with visual indicators and priority handling
  - [ ] Create escalation notification aggregation to prevent notification overflow
  - [ ] Implement escalation acknowledgment tracking with response requirement management
- [ ] Create multi-level escalation workflow (AC: 1)
  - [ ] Build progressive escalation system with increasing notification scope and urgency
  - [ ] Implement escalation hierarchy traversal with automatic supervisor chain notification
  - [ ] Add escalation level tracking with timestamp logging and resolution monitoring
  - [ ] Create escalation bypass mechanisms for emergency situations and special cases
  - [ ] Implement escalation resolution tracking with closure confirmation and feedback collection
- [ ] Implement overdue report identification and tracking (AC: 1)
  - [ ] Build overdue report detection with configurable aging thresholds for different workflow stages
  - [ ] Create overdue report categorization by severity, outlet priority, and business impact
  - [ ] Implement overdue report dashboard integration with supervisor-specific visibility
  - [ ] Add overdue report trend analysis for bottleneck identification and resource planning
  - [ ] Create overdue report resolution tracking with time-to-resolution metrics and reporting
- [ ] Build escalation analytics and reporting system (AC: 1)
  - [ ] Create escalation metrics tracking with frequency analysis and pattern identification
  - [ ] Implement bottleneck identification system with root cause analysis and recommendations
  - [ ] Add escalation trend reporting with historical analysis and seasonal pattern recognition
  - [ ] Create team performance correlation analysis with escalation frequency and resolution times
  - [ ] Implement escalation prevention recommendations based on historical data and successful patterns
- [ ] Create escalation notification delivery system (AC: 1)
  - [ ] Build multi-channel escalation notification delivery with email, SMS, and in-app alerts
  - [ ] Implement escalation notification priority handling with immediate delivery for critical alerts
  - [ ] Add escalation notification retry mechanisms with delivery confirmation and fallback options
  - [ ] Create escalation notification scheduling with supervisor availability and preference consideration
  - [ ] Implement escalation notification audit trail with delivery tracking and response monitoring
- [ ] Integrate with existing notification infrastructure (AC: 1)
  - [ ] Connect escalation system with existing notification service for unified delivery and management
  - [ ] Extend real-time notification capabilities for immediate escalation alert delivery
  - [ ] Integrate with dashboard systems for escalation visibility and action capabilities
  - [ ] Connect with workflow services for escalation event triggers and status updates
  - [ ] Implement notification preference integration for escalation-specific user settings
- [ ] Create escalation management interface (AC: 1)
  - [ ] Build EscalationCenter component for supervisor oversight and escalation management
  - [ ] Implement escalation acknowledgment interface with response tracking and action logging
  - [ ] Add escalation resolution workflow with closure confirmation and feedback collection
  - [ ] Create escalation investigation tools with detailed workflow analysis and bottleneck identification
  - [ ] Implement escalation prevention interface with proactive monitoring and early intervention capabilities
- [ ] Create server actions for escalation operations (AC: 1)
  - [ ] Build processEscalations server action for automated escalation detection and processing
  - [ ] Build acknowledgeEscalation server action for supervisor response tracking and workflow continuation
  - [ ] Build resolveEscalation server action for escalation closure with resolution tracking
  - [ ] Build updateEscalationConfig server action for configuration management and rule updates
  - [ ] Implement escalation analytics server actions for reporting and trend analysis
- [ ] Create comprehensive testing for escalation system (Testing requirement)
  - [ ] Create unit tests for escalation detection logic and timing calculations
  - [ ] Test escalation notification delivery and multi-channel integration
  - [ ] Test escalation progression and hierarchy traversal functionality
  - [ ] Test server actions for escalation operations and configuration management
  - [ ] Test escalation analytics and reporting accuracy with historical data
  - [ ] Test integration with existing notification and workflow services
  - [ ] Test escalation prevention and early intervention mechanisms

## Dev Notes

### Previous Story Dependencies
From Story 4.7b Status Dashboard for Pending Reports:
- Dashboard analytics provide foundation for escalation threshold identification and bottleneck analysis
- Pending report visualization supports escalation monitoring interface and supervisor oversight capabilities
- Workflow metrics tracking enables escalation trend analysis and prevention recommendations
- Report aging calculations provide essential data for escalation timing and threshold evaluation
- Role-based dashboard access patterns support escalation management interface and supervisor tools

From Story 4.7a Real-time Workflow Notifications:
- Real-time notification infrastructure provides foundation for immediate escalation alert delivery
- SSE connection management supports real-time escalation notification streaming and immediate delivery
- Notification service integration enables escalation-specific notification channels and delivery management
- Notification aggregation patterns prevent escalation notification overflow and improve user experience
- User targeting system supports escalation hierarchy notification and supervisor-specific alert delivery

From Story 4.6 Correction Cycle Management:
- Correction deadline tracking provides critical data for escalation timing and overdue identification
- Rejection workflow integration enables escalation triggers for prolonged correction cycles
- Correction history tracking supports escalation context and repeated issue identification
- Manager correction interface provides integration points for escalation intervention and resolution
- Correction timing analytics support escalation threshold configuration and optimization

From Story 4.5 Approval and Rejection Workflow:
- Approval workflow timing provides baseline data for escalation threshold configuration
- Workflow audit trail supports escalation context generation and historical analysis
- Role-based approval permissions ensure proper escalation hierarchy and supervisor targeting
- Batch approval delays contribute to escalation scenarios requiring supervisor intervention
- Approval bottleneck identification supports escalation prevention and resource allocation

### Tech Stack Requirements
[Source: architecture/tech-stack.md]
- Frontend Framework: Next.js v14+ App Router for escalation management interface and scheduled processing
- UI Component Library: shadcn/ui v4 for escalation alert components and management dashboard interfaces
- State Management: Zustand v4.4+ for escalation state management and real-time alert handling
- Database: PostgreSQL v15+ for escalation tracking, configuration storage, and analytics data
- Cache: Vercel KV (Redis) for escalation event queuing and scheduled processing coordination
- Backend Framework: Next.js API Routes for escalation processing endpoints and scheduled job triggers
- Authentication: NextAuth.js v4+ for supervisor authentication and escalation management access
- Frontend Testing: Jest + Testing Library v29+/13+ for escalation component and alert testing

### Component Architecture Requirements
[Source: architecture/components.md and frontend-architecture.md]
**Escalation Component Location**: `src/components/escalation/` directory for escalation management components
**Integration Pattern**: Service-driven architecture with scheduled processing and event-driven notifications
**State Management**: React Query for escalation data management, Zustand for real-time escalation alerts
**Scheduled Processing**: Cron jobs for escalation detection and automated processing
**Alert System**: Multi-channel delivery with escalation-specific priority handling

### Notification Service Integration
[Source: architecture/components.md#notification-service]
**Enhanced Service Interfaces for Escalation Support**:
- `sendEscalationAlert(supervisorId, escalation, priority)` - Critical escalation alert delivery with priority handling
- `processEscalationQueue(threshold)` - Batch escalation processing with configurable timing thresholds
- `notifyEscalationHierarchy(escalation, level)` - Progressive escalation notification with hierarchy traversal
- `scheduleEscalationCheck(reportId, threshold)` - Scheduled escalation monitoring with automated triggers
- `aggregateEscalationAlerts(supervisorId, timeframe)` - Escalation alert aggregation for supervisor digest
**Dependencies**: Sales Report Workflow Service (escalation triggers), Authentication Service (supervisor targeting), Dashboard Service (escalation visibility)
**Technology Stack**: Scheduled processing via cron jobs, multi-channel delivery, real-time alerts via SSE

### Sales Report Workflow Service Integration
[Source: architecture/components.md#sales-report-workflow-service]
**Enhanced Service Interfaces for Escalation Triggers**:
- `checkReportEscalation(reportId, currentStatus)` - Individual report escalation evaluation with status-based timing
- `getEscalationCandidates(threshold)` - Bulk escalation candidate identification with configurable criteria
- `triggerEscalationEvent(reportId, escalationType, context)` - Escalation event generation with detailed context
- `resolveEscalation(reportId, resolution, supervisorId)` - Escalation resolution tracking with closure confirmation
**Escalation Event Requirements**: Detailed context data, supervisor targeting information, resolution tracking capabilities
**Business Rule Integration**: Configurable thresholds, outlet-specific rules, holiday and weekend considerations

### Database Schema Requirements
**Escalation Management Tables**:
```sql
-- Create escalation configuration table
CREATE TABLE escalation_configurations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  outlet_id UUID REFERENCES outlets(id), -- NULL for global config
  report_type VARCHAR(50), -- NULL for all report types
  priority_level INTEGER NOT NULL DEFAULT 1, -- 1=highest priority
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Create escalation thresholds table
CREATE TABLE escalation_thresholds (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  configuration_id UUID REFERENCES escalation_configurations(id) NOT NULL,
  workflow_stage VARCHAR(50) NOT NULL, -- 'SUBMISSION', 'REVIEW', 'CORRECTION'
  level_number INTEGER NOT NULL, -- 1=first escalation, 2=second, etc.
  threshold_hours INTEGER NOT NULL,
  supervisor_role VARCHAR(50) NOT NULL, -- Role to escalate to
  notification_methods TEXT[] DEFAULT ARRAY['IN_APP'], -- 'EMAIL', 'SMS', 'IN_APP'
  is_business_hours_only BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Create escalation events table
CREATE TABLE escalation_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sales_report_id UUID REFERENCES sales_reports(id) NOT NULL,
  escalation_level INTEGER NOT NULL,
  escalation_type VARCHAR(50) NOT NULL, -- 'OVERDUE_SUBMISSION', 'OVERDUE_REVIEW', 'OVERDUE_CORRECTION'
  trigger_reason TEXT NOT NULL,
  triggered_at TIMESTAMPTZ DEFAULT now(),
  escalated_to UUID REFERENCES users(id), -- Supervisor who received escalation
  acknowledged_at TIMESTAMPTZ,
  acknowledged_by UUID REFERENCES users(id),
  resolved_at TIMESTAMPTZ,
  resolved_by UUID REFERENCES users(id),
  resolution_notes TEXT,
  metadata JSONB, -- Additional escalation context
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Create escalation notifications table
CREATE TABLE escalation_notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  escalation_event_id UUID REFERENCES escalation_events(id) NOT NULL,
  notification_id UUID REFERENCES workflow_notifications(id), -- Link to main notifications
  recipient_id UUID REFERENCES users(id) NOT NULL,
  delivery_method VARCHAR(20) NOT NULL, -- 'EMAIL', 'SMS', 'IN_APP'
  delivery_status VARCHAR(20) DEFAULT 'PENDING', -- 'PENDING', 'SENT', 'DELIVERED', 'FAILED'
  delivery_attempts INTEGER DEFAULT 0,
  last_attempt_at TIMESTAMPTZ,
  delivered_at TIMESTAMPTZ,
  error_message TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Create escalation metrics table
CREATE TABLE escalation_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  metric_date DATE NOT NULL,
  outlet_id UUID REFERENCES outlets(id),
  escalation_type VARCHAR(50) NOT NULL,
  total_escalations INTEGER DEFAULT 0,
  resolved_escalations INTEGER DEFAULT 0,
  avg_resolution_time_hours DECIMAL(10,2),
  repeat_escalations INTEGER DEFAULT 0,
  prevention_opportunities INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Create escalation hierarchy table
CREATE TABLE escalation_hierarchy (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  outlet_id UUID REFERENCES outlets(id),
  role VARCHAR(50) NOT NULL,
  level INTEGER NOT NULL, -- 1=first level supervisor, 2=second level, etc.
  supervisor_id UUID REFERENCES users(id) NOT NULL,
  escalation_threshold_override INTEGER, -- Override default thresholds for this supervisor
  notification_preferences JSONB DEFAULT '{}',
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Create escalation business rules table
CREATE TABLE escalation_business_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  rule_name VARCHAR(255) NOT NULL,
  rule_type VARCHAR(50) NOT NULL, -- 'TIMING', 'EXEMPTION', 'PRIORITY'
  conditions JSONB NOT NULL, -- Rule conditions and parameters
  actions JSONB NOT NULL, -- Actions to take when rule matches
  is_active BOOLEAN DEFAULT TRUE,
  priority INTEGER DEFAULT 1,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Create escalation audit log table
CREATE TABLE escalation_audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  escalation_event_id UUID REFERENCES escalation_events(id),
  action VARCHAR(50) NOT NULL, -- 'CREATED', 'ACKNOWLEDGED', 'RESOLVED', 'ESCALATED', 'DISMISSED'
  performed_by UUID REFERENCES users(id),
  previous_state JSONB,
  new_state JSONB,
  change_reason TEXT,
  system_action BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_escalation_configurations_outlet ON escalation_configurations(outlet_id);
CREATE INDEX idx_escalation_configurations_active ON escalation_configurations(is_active);
CREATE INDEX idx_escalation_thresholds_config ON escalation_thresholds(configuration_id);
CREATE INDEX idx_escalation_thresholds_stage ON escalation_thresholds(workflow_stage);
CREATE INDEX idx_escalation_events_report ON escalation_events(sales_report_id);
CREATE INDEX idx_escalation_events_level ON escalation_events(escalation_level);
CREATE INDEX idx_escalation_events_type ON escalation_events(escalation_type);
CREATE INDEX idx_escalation_events_triggered ON escalation_events(triggered_at);
CREATE INDEX idx_escalation_events_resolved ON escalation_events(resolved_at);
CREATE INDEX idx_escalation_notifications_event ON escalation_notifications(escalation_event_id);
CREATE INDEX idx_escalation_notifications_recipient ON escalation_notifications(recipient_id);
CREATE INDEX idx_escalation_metrics_date ON escalation_metrics(metric_date);
CREATE INDEX idx_escalation_metrics_outlet ON escalation_metrics(outlet_id);
CREATE INDEX idx_escalation_hierarchy_outlet ON escalation_hierarchy(outlet_id);
CREATE INDEX idx_escalation_hierarchy_supervisor ON escalation_hierarchy(supervisor_id);
CREATE INDEX idx_escalation_business_rules_type ON escalation_business_rules(rule_type);
CREATE INDEX idx_escalation_audit_log_event ON escalation_audit_log(escalation_event_id);
```

### Data Model Extensions
[Source: Previous stories and escalation architecture]
**Escalation Interface Definitions**:
```typescript
interface EscalationConfiguration {
  id: string;
  name: string;
  description?: string;
  isActive: boolean;
  outletId?: string; // Global if null
  reportType?: string; // All types if null
  priorityLevel: number;
  thresholds: EscalationThreshold[];
  createdAt: Date;
  updatedAt: Date;
}

interface EscalationThreshold {
  id: string;
  configurationId: string;
  workflowStage: WorkflowStage;
  levelNumber: number;
  thresholdHours: number;
  supervisorRole: string;
  notificationMethods: NotificationMethod[];
  isBusinessHoursOnly: boolean;
  createdAt: Date;
}

enum WorkflowStage {
  SUBMISSION = 'SUBMISSION',
  REVIEW = 'REVIEW',
  CORRECTION = 'CORRECTION',
  APPROVAL = 'APPROVAL'
}

enum NotificationMethod {
  EMAIL = 'EMAIL',
  SMS = 'SMS',
  IN_APP = 'IN_APP',
  PUSH = 'PUSH'
}

interface EscalationEvent {
  id: string;
  salesReportId: string;
  escalationLevel: number;
  escalationType: EscalationType;
  triggerReason: string;
  triggeredAt: Date;
  escalatedTo?: string; // User ID of supervisor
  acknowledgedAt?: Date;
  acknowledgedBy?: string;
  resolvedAt?: Date;
  resolvedBy?: string;
  resolutionNotes?: string;
  metadata?: EscalationMetadata;
  notifications: EscalationNotification[];
  auditLog: EscalationAuditEntry[];
  createdAt: Date;
}

enum EscalationType {
  OVERDUE_SUBMISSION = 'OVERDUE_SUBMISSION',
  OVERDUE_REVIEW = 'OVERDUE_REVIEW',
  OVERDUE_CORRECTION = 'OVERDUE_CORRECTION',
  OVERDUE_APPROVAL = 'OVERDUE_APPROVAL',
  REPEATED_REJECTION = 'REPEATED_REJECTION',
  SYSTEM_BOTTLENECK = 'SYSTEM_BOTTLENECK'
}

interface EscalationMetadata {
  outletName?: string;
  reportDate?: string;
  currentStatus?: string;
  ageHours?: number;
  previousEscalations?: number;
  workflowHistory?: WorkflowHistoryEntry[];
  businessImpact?: BusinessImpactLevel;
  seasonalFactor?: number;
  [key: string]: any;
}

enum BusinessImpactLevel {
  CRITICAL = 'CRITICAL', // Major business disruption
  HIGH = 'HIGH',         // Significant impact
  MEDIUM = 'MEDIUM',     // Moderate impact
  LOW = 'LOW'            // Minimal impact
}

interface EscalationNotification {
  id: string;
  escalationEventId: string;
  notificationId: string; // Reference to main notification
  recipientId: string;
  deliveryMethod: NotificationMethod;
  deliveryStatus: DeliveryStatus;
  deliveryAttempts: number;
  lastAttemptAt?: Date;
  deliveredAt?: Date;
  errorMessage?: string;
  createdAt: Date;
}

enum DeliveryStatus {
  PENDING = 'PENDING',
  SENT = 'SENT',
  DELIVERED = 'DELIVERED',
  FAILED = 'FAILED',
  RETRY = 'RETRY'
}

interface EscalationMetrics {
  id: string;
  metricDate: Date;
  outletId?: string;
  escalationType: EscalationType;
  totalEscalations: number;
  resolvedEscalations: number;
  avgResolutionTimeHours: number;
  repeatEscalations: number;
  preventionOpportunities: number;
  createdAt: Date;
  updatedAt: Date;
}

interface EscalationHierarchy {
  id: string;
  outletId?: string; // Global if null
  role: string;
  level: number;
  supervisorId: string;
  escalationThresholdOverride?: number;
  notificationPreferences: EscalationNotificationPreferences;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

interface EscalationNotificationPreferences {
  preferredMethods: NotificationMethod[];
  quietHours?: {
    start: string;
    end: string;
  };
  immediateEscalationTypes: EscalationType[];
  aggregationWindow: number; // Minutes
  maxConcurrentAlerts: number;
}

interface EscalationBusinessRule {
  id: string;
  ruleName: string;
  ruleType: BusinessRuleType;
  conditions: RuleConditions;
  actions: RuleActions;
  isActive: boolean;
  priority: number;
  createdAt: Date;
  updatedAt: Date;
}

enum BusinessRuleType {
  TIMING = 'TIMING',       // Timing-based rules
  EXEMPTION = 'EXEMPTION', // Exemption rules
  PRIORITY = 'PRIORITY',   // Priority modification rules
  ROUTING = 'ROUTING'      // Escalation routing rules
}

interface RuleConditions {
  outletIds?: string[];
  reportTypes?: string[];
  timeOfDay?: TimeRange;
  dayOfWeek?: number[];
  seasonalPeriods?: string[];
  workflowStage?: WorkflowStage[];
  userRoles?: string[];
  customConditions?: Record<string, any>;
}

interface RuleActions {
  skipEscalation?: boolean;
  adjustThreshold?: number; // Hours to add/subtract
  changePriority?: BusinessImpactLevel;
  routeToSpecificSupervisor?: string;
  addNotificationMethods?: NotificationMethod[];
  customActions?: Record<string, any>;
}

interface EscalationAuditEntry {
  id: string;
  escalationEventId: string;
  action: EscalationAction;
  performedBy?: string;
  previousState?: any;
  newState?: any;
  changeReason?: string;
  systemAction: boolean;
  createdAt: Date;
}

enum EscalationAction {
  CREATED = 'CREATED',
  ACKNOWLEDGED = 'ACKNOWLEDGED',
  RESOLVED = 'RESOLVED',
  ESCALATED = 'ESCALATED',
  DISMISSED = 'DISMISSED',
  MODIFIED = 'MODIFIED'
}

interface EscalationAnalytics {
  totalEscalations: number;
  resolvedEscalations: number;
  avgResolutionTime: number;
  escalationsByType: Record<EscalationType, number>;
  escalationsByOutlet: OutletEscalationData[];
  trendData: EscalationTrendData[];
  bottleneckAnalysis: BottleneckAnalysis[];
  preventionOpportunities: PreventionOpportunity[];
}

interface OutletEscalationData {
  outletId: string;
  outletName: string;
  escalationCount: number;
  avgResolutionTime: number;
  mostCommonType: EscalationType;
  improvementPotential: number; // Percentage
}

interface EscalationTrendData {
  date: Date;
  escalationCount: number;
  resolutionCount: number;
  avgResolutionTime: number;
  preventedEscalations: number;
}

interface PreventionOpportunity {
  type: string;
  description: string;
  potentialSavings: number; // Hours
  implementationEffort: EffortLevel;
  priority: number;
}

enum EffortLevel {
  LOW = 'LOW',
  MEDIUM = 'MEDIUM',
  HIGH = 'HIGH',
  VERY_HIGH = 'VERY_HIGH'
}
```

### Escalation Component Design
**EscalationCenter Component Structure**:
```typescript
interface EscalationCenterProps {
  supervisorId: string;
  role: string;
  outletIds?: string[];
  initialFilters?: EscalationFilters;
}

interface EscalationFilters {
  escalationTypes: EscalationType[];
  priorities: BusinessImpactLevel[];
  dateRange: DateRange;
  outlets: string[];
  status: EscalationStatus[];
  searchTerm: string;
}

enum EscalationStatus {
  PENDING = 'PENDING',
  ACKNOWLEDGED = 'ACKNOWLEDGED',
  IN_PROGRESS = 'IN_PROGRESS',
  RESOLVED = 'RESOLVED',
  DISMISSED = 'DISMISSED'
}

interface EscalationState {
  escalations: EscalationEvent[];
  filters: EscalationFilters;
  loading: boolean;
  error: string | null;
  selectedEscalations: string[];
  totalCount: number;
  currentPage: number;
  analytics: EscalationAnalytics;
}
```

**EscalationAlert Component Structure**:
```typescript
interface EscalationAlertProps {
  escalation: EscalationEvent;
  onAcknowledge: (escalationId: string, notes?: string) => void;
  onResolve: (escalationId: string, resolution: EscalationResolution) => void;
  onEscalate: (escalationId: string, targetSupervisor: string) => void;
  showActions: boolean;
}

interface EscalationResolution {
  resolutionType: ResolutionType;
  notes: string;
  preventionActions?: PreventionAction[];
  followUpRequired: boolean;
  followUpDate?: Date;
}

enum ResolutionType {
  WORKFLOW_RESUMED = 'WORKFLOW_RESUMED',
  ISSUE_RESOLVED = 'ISSUE_RESOLVED',
  EXEMPTION_APPLIED = 'EXEMPTION_APPLIED',
  ESCALATED_FURTHER = 'ESCALATED_FURTHER',
  DISMISSED_INVALID = 'DISMISSED_INVALID'
}

interface PreventionAction {
  actionType: string;
  description: string;
  responsible: string;
  dueDate: Date;
  priority: number;
}
```

**EscalationConfig Component Structure**:
```typescript
interface EscalationConfigProps {
  configurations: EscalationConfiguration[];
  onSave: (config: EscalationConfiguration) => void;
  onDelete: (configId: string) => void;
  availableOutlets: Outlet[];
  availableRoles: Role[];
}

interface ConfigurationFormData {
  name: string;
  description: string;
  outletId?: string;
  reportType?: string;
  priorityLevel: number;
  thresholds: ThresholdFormData[];
}

interface ThresholdFormData {
  workflowStage: WorkflowStage;
  levelNumber: number;
  thresholdHours: number;
  supervisorRole: string;
  notificationMethods: NotificationMethod[];
  isBusinessHoursOnly: boolean;
}
```

### Scheduled Processing and Automation
**Escalation Detection Service**:
```typescript
class EscalationDetectionService {
  async processEscalationQueue(): Promise<void> {
    const candidates = await this.getEscalationCandidates();

    for (const candidate of candidates) {
      const escalationRequired = await this.evaluateEscalation(candidate);

      if (escalationRequired) {
        await this.createEscalationEvent(candidate);
      }
    }
  }

  async evaluateEscalation(report: SalesReport): Promise<boolean> {
    const config = await this.getEscalationConfig(report.outletId, report.type);
    const businessRules = await this.getApplicableBusinessRules(report);
    const currentAge = this.calculateReportAge(report);

    return this.applyEscalationLogic(config, businessRules, currentAge, report);
  }

  async createEscalationEvent(report: SalesReport): Promise<EscalationEvent> {
    const escalation = await this.buildEscalationEvent(report);
    const notifications = await this.prepareEscalationNotifications(escalation);

    await this.saveEscalationEvent(escalation);
    await this.sendEscalationNotifications(notifications);

    return escalation;
  }
}
```

**Cron Job Implementation**:
```typescript
// Scheduled escalation processing every 15 minutes
export async function escalationCronJob() {
  try {
    const escalationService = new EscalationDetectionService();
    await escalationService.processEscalationQueue();

    // Log successful processing
    console.log(`Escalation processing completed at ${new Date().toISOString()}`);
  } catch (error) {
    console.error('Escalation processing failed:', error);
    // Send alert to administrators
    await sendSystemAlert('Escalation processing failure', error);
  }
}
```

### Multi-Channel Notification Delivery
**Escalation Notification Delivery**:
```typescript
interface EscalationNotificationDelivery {
  sendEscalationAlert(
    escalation: EscalationEvent,
    recipients: SupervisorRecipient[],
    priority: NotificationPriority
  ): Promise<DeliveryResult[]>;

  sendProgressiveEscalation(
    escalation: EscalationEvent,
    hierarchy: EscalationHierarchy[]
  ): Promise<void>;

  sendEscalationResolution(
    escalation: EscalationEvent,
    resolution: EscalationResolution
  ): Promise<void>;
}

interface SupervisorRecipient {
  supervisorId: string;
  role: string;
  preferredMethods: NotificationMethod[];
  urgencyThreshold: number;
}

interface DeliveryResult {
  recipientId: string;
  method: NotificationMethod;
  status: DeliveryStatus;
  attempts: number;
  errorMessage?: string;
}
```

### Escalation Analytics and Insights
**Analytics Processing**:
```typescript
interface EscalationAnalyticsService {
  generateEscalationMetrics(dateRange: DateRange): Promise<EscalationAnalytics>;
  identifyBottlenecks(outletIds?: string[]): Promise<BottleneckAnalysis[]>;
  calculatePreventionOpportunities(): Promise<PreventionOpportunity[]>;
  generateTrendAnalysis(period: AnalysisPeriod): Promise<EscalationTrendData[]>;
}

enum AnalysisPeriod {
  DAILY = 'DAILY',
  WEEKLY = 'WEEKLY',
  MONTHLY = 'MONTHLY',
  QUARTERLY = 'QUARTERLY',
  YEARLY = 'YEARLY'
}
```

### File Locations
[Source: architecture/unified-project-structure.md]
- Escalation Components: `src/components/escalation/` directory (new)
  - `EscalationCenter.tsx` - Main escalation management interface
  - `EscalationAlert.tsx` - Individual escalation display and action component
  - `EscalationConfig.tsx` - Configuration management interface
  - `EscalationAnalytics.tsx` - Analytics and metrics display component
  - `EscalationTimeline.tsx` - Escalation history and timeline visualization
  - `EscalationHierarchy.tsx` - Supervisor hierarchy management interface
- Escalation Services: `src/services/escalation/` directory (new)
  - `EscalationDetectionService.ts` - Automated escalation detection and processing
  - `EscalationNotificationService.ts` - Multi-channel notification delivery
  - `EscalationAnalyticsService.ts` - Analytics and reporting service
- Scheduled Jobs: `src/jobs/escalation-cron.ts` (new file)
- API Endpoints: `app/api/escalations/` directory (new)
  - `route.ts` - Main escalation API endpoints
  - `process/route.ts` - Escalation processing endpoint
  - `config/route.ts` - Configuration management endpoint
- Server Actions: `app/actions/escalation-actions.ts` (new file)
- Type Definitions: `types/escalation.ts` (new file)
- Custom Hooks: `src/hooks/useEscalations.ts`, `src/hooks/useEscalationConfig.ts` (new files)
- Test Files: `src/__tests__/services/escalation/` directory (new)
- Database Migrations: `prisma/migrations/add-escalation-system.sql` (new)

### Coding Standards
[Source: architecture/coding-standards.md]
- **Component Naming**: Use PascalCase for escalation components (`EscalationCenter.tsx`)
- **API Routes**: Use kebab-case for escalation routes (`/api/escalations/process`)
- **Type Sharing**: Define escalation types in `types/escalation.ts` for consistent interfaces
- **Error Handling**: All escalation operations must use standard error handling patterns
- **State Updates**: Use proper state management patterns with immutable updates for escalation state
- **Scheduled Jobs**: Implement proper error handling and logging for automated processes

### Authentication and Role-Based Access
[Source: architecture/components.md#authentication-service]
**Required Role Validation**:
- Escalation management restricted to supervisor and admin roles
- Escalation configuration access limited to admin users
- Role-based escalation visibility with appropriate data filtering
- Audit trail tracking for all escalation management actions
- Escalation hierarchy validation with proper supervisor chain verification

### Business Rules and Configuration
**Configurable Business Rules**:
- Working hours consideration for escalation timing
- Holiday and weekend exemptions for non-critical escalations
- Outlet-specific escalation thresholds based on business priority
- Seasonal adjustment factors for tourism-related business cycles
- Emergency bypass mechanisms for critical situations

**Escalation Timing Examples**:
- Submission to Review: 4 hours (Level 1), 8 hours (Level 2)
- Review to Approval: 2 hours (Level 1), 6 hours (Level 2)
- Rejection to Correction: 12 hours (Level 1), 24 hours (Level 2)
- Correction to Resubmission: 24 hours (Level 1), 48 hours (Level 2)

### Integration with Existing Workflow
**Seamless Workflow Integration**:
- Escalation events automatically logged in workflow audit trail
- Dashboard integration for escalation visibility and quick resolution
- Notification system enhancement for escalation-specific alert handling
- Report status updates with escalation context and resolution tracking
- Performance metrics integration for escalation impact measurement

**Prevention and Early Intervention**:
- Proactive monitoring for workflow patterns indicating potential escalations
- Early warning systems for reports approaching escalation thresholds
- Automated coaching suggestions for team members with frequent escalations
- Resource allocation recommendations based on escalation trends and bottleneck analysis

### Performance and Scalability
**Escalation Processing Optimization**:
- Efficient database queries with proper indexing for escalation detection
- Batch processing for multiple escalation evaluations
- Caching of escalation configurations and business rules
- Asynchronous notification delivery with queue management
- Database connection pooling for high-volume escalation processing

**Monitoring and Alerting**:
- System health monitoring for escalation processing performance
- Alert thresholds for escalation system failures and delays
- Performance metrics tracking for escalation detection and resolution times
- Capacity planning based on escalation volume trends and business growth

### Project Structure Notes
Escalation system integrates deeply with existing workflow architecture while adding comprehensive automation and supervisor oversight capabilities. Component architecture follows established patterns with service-layer separation for complex business logic. Scheduled processing leverages Next.js capabilities for reliable automation. Integration with notification and dashboard services maintains consistent user experience patterns. Analytics and reporting provide actionable insights for continuous workflow improvement.

## Testing
[Source: architecture/testing-strategy.md]
- **Frontend Unit Testing**: Jest + Testing Library v29+/13+ for escalation component and configuration testing
- **Integration Testing**: Jest + Supertest for escalation server actions and scheduled job validation
- **E2E Testing**: Playwright for complete escalation workflow validation across supervisor roles and scenarios
- **Test Locations**:
  - `src/__tests__/components/escalation/EscalationCenter.test.tsx` - Main escalation management interface testing
  - `src/__tests__/components/escalation/EscalationAlert.test.tsx` - Alert component and action testing
  - `src/__tests__/components/escalation/EscalationConfig.test.tsx` - Configuration interface testing
  - `src/__tests__/services/escalation/EscalationDetectionService.test.ts` - Detection logic and business rule testing
  - `src/__tests__/services/escalation/EscalationNotificationService.test.ts` - Notification delivery testing
  - `src/__tests__/hooks/useEscalations.test.ts` - Escalation hook testing with mock data
  - `src/__tests__/actions/escalation-actions.test.ts` - Server action testing for escalation operations
  - `src/__tests__/jobs/escalation-cron.test.ts` - Scheduled job testing with time simulation
  - `tests/e2e/escalation-workflow.spec.ts` - End-to-end escalation and resolution testing
- **Testing Scenarios**:
  - Escalation detection accuracy with various timing scenarios and business rules
  - Multi-channel notification delivery with delivery confirmation and retry mechanisms
  - Escalation hierarchy traversal and progressive escalation functionality
  - Configuration management with validation and business rule application
  - Scheduled job reliability with error handling and recovery mechanisms
  - Role-based access control and permission validation for supervisor functions
  - Analytics accuracy with historical data and trend calculation validation
  - Integration testing with existing workflow and notification services
  - Performance testing with high-volume escalation scenarios and concurrent processing
  - Time-based testing with business hours, holidays, and timezone considerations

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-17 | 1.0 | Initial story creation for escalation notifications and timing | Claude Code |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4 (claude-sonnet-4-20250514) - Full Stack Developer Agent

### Implementation Status
**PENDING** - Story ready for development

### Completion Notes
*This section will be populated during implementation*

### File List
*This section will be populated during implementation*

### Debug Log References
*This section will be populated during implementation*

## QA Results

*This section will be populated by the QA agent during review*